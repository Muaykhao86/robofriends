{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.whyDidYouUpdate = undefined;\n\nvar _deepDiff = require('./deepDiff');\n\nvar _getDisplayName = require('./getDisplayName');\n\nvar _normalizeOptions = require('./normalizeOptions');\n\nvar _shouldInclude = require('./shouldInclude');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar memoized = function memoized(map, key, fn) {\n  // key already in the memoizer\n  if (map.has(key)) {\n    return map.get(key);\n  } // key not in memoizer,\n  // evaluate the function to get the value\n  // to store in our memoizer.\n\n\n  var ret = fn();\n  map.set(key, ret);\n  return ret;\n};\n\nfunction createComponentDidUpdate(displayName, opts) {\n  return function componentDidUpdate(prevProps, prevState) {\n    var propsDiff = (0, _deepDiff.classifyDiff)(prevProps, this.props, displayName + '.props');\n\n    if (propsDiff.type === _deepDiff.DIFF_TYPES.UNAVOIDABLE) {\n      return;\n    }\n\n    var stateDiff = (0, _deepDiff.classifyDiff)(prevState, this.state, displayName + '.state');\n\n    if (stateDiff.type === _deepDiff.DIFF_TYPES.UNAVOIDABLE) {\n      return;\n    }\n\n    opts.notifier(opts.groupByComponent, opts.collapseComponentGroups, displayName, [propsDiff, stateDiff]);\n  };\n} // Creates a wrapper for a React class component\n\n\nvar createClassComponent = function createClassComponent(ctor, displayName, opts) {\n  var cdu = createComponentDidUpdate(displayName, opts); // the wrapper class extends the original class,\n  // and overwrites its `componentDidUpdate` method,\n  // to allow why-did-you-update to listen for updates.\n  // If the component had its own `componentDidUpdate`,\n  // we call it afterwards.`\n\n  var WDYUClassComponent = function (_ctor) {\n    _inherits(WDYUClassComponent, _ctor);\n\n    function WDYUClassComponent() {\n      _classCallCheck(this, WDYUClassComponent);\n\n      return _possibleConstructorReturn(this, _ctor.apply(this, arguments));\n    }\n\n    WDYUClassComponent.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState, snapshot) {\n      cdu.call(this, prevProps, prevState);\n\n      if (typeof ctor.prototype.componentDidUpdate === 'function') {\n        ctor.prototype.componentDidUpdate.call(this, prevProps, prevState, snapshot);\n      }\n    };\n\n    return WDYUClassComponent;\n  }(ctor); // our wrapper component needs an explicit display name\n  // based on the original constructor.\n\n\n  WDYUClassComponent.displayName = displayName;\n  return WDYUClassComponent;\n}; // Creates a wrapper for a React functional component\n\n\nvar createFunctionalComponent = function createFunctionalComponent(ctor, displayName, opts, ReactComponent) {\n  var cdu = createComponentDidUpdate(displayName, opts); // We call the original function in the render() method,\n  // and implement `componentDidUpdate` for `why-did-you-update`\n\n  var WDYUFunctionalComponent = function (_ReactComponent) {\n    _inherits(WDYUFunctionalComponent, _ReactComponent);\n\n    function WDYUFunctionalComponent() {\n      _classCallCheck(this, WDYUFunctionalComponent);\n\n      return _possibleConstructorReturn(this, _ReactComponent.apply(this, arguments));\n    }\n\n    WDYUFunctionalComponent.prototype.render = function render() {\n      return ctor(this.props, this.context);\n    };\n\n    WDYUFunctionalComponent.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState, snapshot) {\n      cdu.call(this, prevProps, prevState, snapshot);\n    };\n\n    return WDYUFunctionalComponent;\n  }(ReactComponent); // copy all statics from the functional component to the class\n  // to support proptypes and context apis\n\n\n  Object.assign(WDYUFunctionalComponent, ctor, {\n    // our wrapper component needs an explicit display name\n    // based on the original constructor.\n    displayName: displayName\n  });\n  return WDYUFunctionalComponent;\n};\n\nvar whyDidYouUpdate = exports.whyDidYouUpdate = function whyDidYouUpdate(React) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opts = (0, _normalizeOptions.normalizeOptions)(opts); // Store the original `React.createElement`,\n  // which we're going to reference in our own implementation\n  // and which we put back when we remove `whyDidYouUpdate` from React.\n\n  var _createReactElement = React.createElement; // The memoizer is a JavaScript map that allows us to return\n  // the same WrappedComponent for the same original constructor.\n  // This ensure that by wrapping the constructor, we don't break\n  // React's reconciliation process.\n\n  var memo = new Map(); // Our new implementation of `React.createElement` works by\n  // replacing the element constructor with a class that wraps it.\n\n  React.createElement = function (type) {\n    var ctor = type;\n    var displayName = (0, _getDisplayName.getDisplayName)(ctor); // the element is a class component or a functional component\n\n    if (typeof ctor === 'function' && (0, _shouldInclude.shouldInclude)(displayName, opts)) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        // If the constructor has a `render` method in its prototype,\n        // we're dealing with a class component\n        ctor = memoized(memo, ctor, function () {\n          return createClassComponent(ctor, displayName, opts);\n        });\n      } else {\n        // If the constructor function has no `render`,\n        // it must be a simple functioanl component.\n        ctor = memoized(memo, ctor, function () {\n          return createFunctionalComponent(ctor, displayName, opts, React.Component);\n        });\n      }\n    } // Call the old `React.createElement,\n    // but with our overwritten constructor\n\n\n    for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    return _createReactElement.apply(React, [ctor].concat(rest));\n  };\n\n  React.__WHY_DID_YOU_UPDATE_RESTORE_FN__ = function () {\n    React.createElement = _createReactElement;\n    delete React.__WHY_DID_YOU_UPDATE_RESTORE_FN__;\n  };\n\n  return React;\n};\n\nexports.default = whyDidYouUpdate;","map":null,"metadata":{},"sourceType":"script"}